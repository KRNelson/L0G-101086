# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2018 Jacob Keller. All rights reserved.


# Custom user-specific data
#
# Some of this scripts functionality depends on custom data which cannot be
# shared. This section describes each variable, hopefully with enough
# information that you can fill it in yourself.

# The discord map is a mapping of GW2 account names to discord user
# ids. In order for them to display properly in the embeds, these
# must be the internal ID used by discord. Usually you can find it
# in discord by typing \@name (for example, "\@serenamyr#8942") into
# a discord channel. You can also find it by right clicking on a chat
# link and selecting "Copy ID" (enabled by the Developer Tools option
# in the discord settings). The full format should be something similar
# to "<@123456789012345>"
#
# Extra entries can be added by putting them separated by semicolons.
$discord_map = @{"Serena Sedai.3064"="<@119167866103791621>";}

# Discord Webhook URL
#
# This should contain the URL for a webhook to your discord server, as shown
# in the webhooks page of the server settings.
$discord_webhook = ""

# Path to the RestSharp dll
#
# This script depends on RestSharp (http://restsharp.org/) to setup it's Rest APIs, as the
# "Invoke-WebRequest" builtin isn't quite powerful enough.
#
# Set this to the complete path where you have downloaded RestSharp.
$restsharp_path = "C:\Users\Administrator\Documents\Guild Wars 2\addons\arcdps\RestSharp.dll"

# gw2raidar API token
#
# This script connects to gw2raidar to obtain a recent encounter list. To
# authenticate properly, you need to setup this token. You can obtain it
# by logging into gw2raidar.com and going to "https://www.gw2raidar.com/api/v2/swagger#/token"
# This site should be able to generate a token for you which you can place in this string.
$gw2raidar_token = ''

# Set this to a glob string to match encounter tags if you raid with multiple groups
# and do not want to include logs for separate groups. For example, setting this to
# "*eV*" will match all encounters who's tages are LIKE *eV*
$gw2raidar_tag = "*eV*"

# Guild Name
# This text will be inserted into the title for the discord post
$guild = ""

# folder containing json as sent to the webhook
#
# This directory stores files which contain the JSON data that we
# ultimately send to the discord webhook. It is useful for debugging purposes
# since you can compare the JSON that we sent to what appears in discord.
# If left empty, then we won't save any data.
$encounters_dir = ""

# path to a file to store the last format time. By default
# this is stored within the encounters directory above
# but can be set to any valid path. This is used to prevent
# searching for and re-posting old encounters every time the
# script is run.
$last_format_file = Join-Path -Path $encounters_dir -ChildPath "last_format_time.json"

# This script requires some extra data generated by upload-logs.ps1 and stored
# in a particular location. This data is generated by the C++ simpleArcParse
# utility, in addition to the upload-logs.ps1 script itself. It contains a series
# of directories key'd off of the local evtc file name, and each folder hosts
# JSON formatted data for the player accounts who participated, the success/failure
# and the uploaded dps.report link if any.
#
# This must be set to the same value as in the upload-logs.ps1 script, otherwise
# things will not function correctly.
$upload_extras = "C:\Users\Administrator\Documents\Guild Wars 2\addons\arcdps\arcdps.uploadextras"

# This script correlates gw2raidar links to the local evtc files (and thus the dps.report files)
# by using the server start time associated with the log. It parses this data out using
# simpleArcParse, which is a C++ program designed to read minimal data from evtc files.
#
# Gw2raidar does not currently provide the original file upload, so we match it based on the
# server start time. To do so, upload-logs.ps1 stores a folder within $start_map named
# after the start time of the encounter, and inside this, hosts a JSON data file which contains
# the local evtc file name. This essenitally builds a mini-database for mapping gw2raidar
# links back to local evtc files so we can obtain player names and the dps.report links
#
# This must be set to the same value as in the upload-logs.ps1 script, otherwise
# things will not function correctly
$start_map = "C:\Users\Administrator\Documents\Guild Wars 2\addons\arcdps\arcdps.startmap"

# Guild Thumbnail
#
# This is a link to an icon to show in the top right corner of the post as a thumbnail.
# We use it as a Guild thumbnail image, but this could be anything. It is expected to
# be a URL to an image file.
$guild_thumbnail = ""

# Convert UTC time into the local time zone
Function ConvertFrom-UTC($utc) {
    [TimeZone]::CurrentTimeZone.ToLocalTime($utc)
}

# Convert a unix timestamp (seconds since the Unix epoch) into a DateTime object
Function ConvertFrom-UnixDate ($UnixDate) {
    ConvertFrom-UTC ([DateTime]'1/1/1970').AddSeconds($UnixDate)
}

# Convert a DateTime object into a unix epoch timestamp
Function ConvertTo-UnixDate ($date) {
    $unixEpoch = [DateTime]'1/1/1970'
    (New-TimeSpan -Start $unixEpoch -End $date).TotalSeconds
}

# Loads account names from the local data directory
Function Get-Local-Players ($boss) {
    $names = @()

    if (!$boss.evtc) {
        return $names
    }

    $accounts = Get-Content -Raw -Path ([io.path]::combine($upload_extras, $boss.evtc, "accounts.json")) | ConvertFrom-Json
    ForEach ($account in ($accounts | Sort)) {
        if ($discord_map.ContainsKey($account)) {
            $names += @($discord_map[$account])
        } elseif ($account -ne "") {
            $names += @("_${account}_")
        }
    }

    return $names
}

# Loads dps.report link from the local data directory
Function Get-Local-DpsReport ($boss) {
    if (!$boss.evtc) {
        return ""
    }

    $dps_json = [io.path]::combine($upload_extras, $boss.evtc, "dpsreport.json")

    if (!(Test-Path -Path $dps_json)) {
        return ""
    }

    $dps_report = Get-Content -Raw -Path $dps_json | ConvertFrom-Json
    return $dps_report.permalink
}

# Load RestSharp
Add-Type -Path $restsharp_path

$gw2raidar_url = "https://gw2raidar.com"
$complete = $false

$nameToId = @{}
$nameToCmId = @{}

# These emoji ids will need to be replaced by the correct ids for your
# discord server. We uploaded the 40px icons from gw2 wiki, and found their
# ids by typing the emote into a channel, prefixed by \.
# The versions shown here will not display correctly even if you have
# an emoji by the same name
$bosses = @(@{name="Vale Guardian";emoji="<:vg:311578870933356545>";wing=1},
            @{name="Gorseval";emoji="<:gors:311578871013310474>";wing=1},
            @{name="Sabetha";emoji="<:sab:311578871122231296>";wing=1},
            @{name="Slothasor";emoji="<:sloth:311578871206117376>";wing=2},
            @{name="Matthias";emoji="<:matt:311578871105454080>";wing=2},
            @{name="Keep Construct";emoji="<:kc:311578870686023682>";wing=3},
            @{name="Xera";emoji="<:xera:311578871277289472>";wing=3},
            @{name="Cairn";emoji="<:cairn:311578870954590208>";wing=4},
            @{name="Mursaat Overseer";emoji="<:mo:311579053486243841>";wing=4},
            @{name="Samarog";emoji="<:sam:311578871214637057>";wing=4},
            @{name="Deimos";emoji="<:deimos:311578870761652225>";wing=4},
            @{name="Soulless Horror";emoji="<:horror:386645168289480715>";wing=5},
            @{name="Dhuum";emoji="<:dhuum:399610319464431627>";wing=5})

# Get the area IDs
$client = New-Object RestSharp.RestClient($gw2raidar_url)
$req = New-Object RestSharp.RestRequest("/api/v2/areas")
$req.AddHeader("Authorization", "Token $gw2raidar_token") | Out-Null
$req.Method = [RestSharp.Method]::GET

$resp = $client.Execute($req)

if ($resp.ResponseStatus -ne [RestSharp.ResponseStatus]::Completed) {
    Read-Host -Prompt "Areas request Failed, press Enter to exit"
    exit
}

$areasResp = $resp.Content | ConvertFrom-Json

# Treat Challenge Mote encounters the same as regular ones
ForEach($area in $areasResp.results) {
    if ($area.name -Match " \(CM\)$") {
        $name = $area.name -Replace " \(CM\)$", ""
        $nameToCmId.Set_Item($name, $area.id)
    } else {
        $nameToId.Set_Item($area.name, $area.id)
    }
}

# Insert IDs
$bosses | ForEach-Object { $name = $_.name; $_.Set_Item("id", $nameToId.$name); $_.Set_Item("cm_id", $nameToCmId.$name) }

# Load the last upload time, or go back forever if we can't find it
if (Test-Path $last_format_file) {
    $last_format_time = Get-Content -Raw -Path $last_format_file | ConvertFrom-Json | Select-Object -ExpandProperty "DateTime" | Get-Date
    $since = ConvertTo-UnixDate ((Get-Date -Date $last_format_time).ToUniversalTime())
} else {
    $since = 0
}

# Limit ourselves to 15 encounters at a time
$request = "/api/v2/encounters?limit=15&since=${since}"

# Main loop for getting gw2raidar links
Do {
    # Request a chunk of encounters
    $client = New-Object RestSharp.RestClient($gw2raidar_url)
    $req = New-Object RestSharp.RestRequest($request)
    $req.AddHeader("Authorization", "Token $gw2raidar_token") | Out-Null
    $req.Method = [RestSharp.Method]::GET

    $resp = $client.Execute($req)

    if ($resp.ResponseStatus -ne [RestSharp.ResponseStatus]::Completed) {
        Read-Host -Prompt "Request Failed, press Enter to exit"
        exit
    }

    $data = $resp.Content | ConvertFrom-Json

    # When we get no further results, break the loop
    if (!($data.results)) {
        break
    }

    # Parse each encounter from the results
    ForEach($encounter in $data.results) {
        $area_id = $encounter.area_id
        $url_id = $encounter.url_id
        $url = "${gw2raidar_url}/encounter/${url_id}"
        $time = ConvertFrom-UnixDate $encounter.started_at
        $age = New-TimeSpan -Start $time

        if (-not ( $encounter.tags -like $gw2raidar_tag ) ) {
            continue
        }

        # See if we have matching local data for this encounter.
        # Local data is accessed from $upload_extras, by using
        # $start_map as a mapping between encounter start time
        # and the local evtc file data that we created using
        # upload-logs.ps1
        $map_dir = Join-Path -Path $start_map -ChildPath $encounter.started_at
        if (Test-Path -Path $map_dir) {
            $evtc_name = Get-Content -Raw -Path (Join-Path -Path $map_dir -ChildPath "evtc.json") | ConvertFrom-Json
        } else {
            $evtc_name = $null
        }

        # Insert the url and other data into the boss list
        #
        # Note that we search in *reverse* (newest first), so as soon as we find
        # a url for a particular encounter we will not overwrite it.
        $bosses | where { -not $_.ContainsKey("url") -and ($_.id -eq $area_id -or $_.cm_id -eq $area_id) } | ForEach-Object { $_.Set_Item("url", $url); $_.Set_Item("age", $age); $_.Set_Item("time", $time); $_.Set_Item("evtc", $evtc_name) }
    }

    # If the gw2raidar API gave us a $next url, then there are more
    # encounters available to check.
    if ($data.next) {
        $request = $data.next -replace $gw2raidar_url, ""
    } else {
        $complete = $true
    }

    # We only want to show the latest run of each boss,
    # so we check to see if we've found a match for every boss
    # encounter. If so, we stop the loop
    if ( $bosses | where { -not $_.ContainsKey("url") } ) {
        # We're still missing boss URLs
    } else {
        $complete = $true
    }

} Until($complete)

# If we didnt't any URLs, this means that there are no
# bosses to publish. Note this excludes the case where
# we happen to have a dps.report without a gw2raidar URL
if (-not ( $bosses | where { $_.ContainsKey("url") } ) ) {
    Read-Host -Prompt "No new encounters to format. Press Enter to exit"
    exit
}

$boss_per_date = @{}

$this_format_time = Get-Date

$datestamp = Get-Date -Date $this_format_time -Format "yyyyMMdd-HHmmss"

# Try to create an $encounters_file to save the JSON data
if (-not (Test-Path $encounters_dir)) {
    $encounters_file = Join-Path -Path $encounters_dir -ChildPath "ev-encounters-${datestamp}.txt"

    if (Test-Path $encounters_file) {
        Read-Host -Prompt "$encounters_file already exists.. Press Enter to Exit"
        exit
    }
} else {
    $encounters_file = $null
}

# We show a set of encounters based on the day that they occurred, so if you
# run some encounters on one day, and some on another, you could run this script
# only on the second day and it would publish two separate pages for each
# day.
$bosses | ForEach-Object {
    # Skip bosses which weren't found
    if (-not $_.ContainsKey("url")) {
        return
    }

    if (-not $boss_per_date.ContainsKey($_.time.Date)) {
        $boss_per_date[$_.time.Date] = @()
    }
    $boss_per_date[$_.time.Date] += ,@($_)
}

# object holding the thumbnail URL
$thumbnail = [PSCustomObject]@{
    url = $guild_thumbnail
}

$data = @()

$boss_per_date.GetEnumerator() | Sort-Object -Property {$_.Key.DayOfWeek}, key | ForEach-Object {
    $date = $_.key
    $some_bosses = $_.value
    $players = @()
    $fields = @()

    # We sort the bosses based on server start time
    ForEach ($boss in $some_bosses | Sort-Object -Property {$_.time}) {
        if ( -not ( $boss.ContainsKey("url") ) ) {
            continue
        }

        $emoji = $boss.emoji
        $name = $boss.name

        $players += Get-Local-Players $boss
        $dps_report = Get-Local-DpsReport $boss

        $url = $boss.url

        # For each boss, we add a field object to the embed
        #
        # Note that PowerShell's default ConvertTo-Jsom does not handle unicode
        # characters very well, so we use @NAME@ replacement strings to represent
        # these characters, which we'll replace after calling ConvertTo-Json
        # See Convert-Payload for more details
        $fields += [PSCustomObject]@{
            # Each boss is just an emoji followed by the full name
            name = "${emoji} **${name}**"
            # We put both the dps.report link and gw2raidar link here. We separate them by a MIDDLE DOT
            # unicode character, and we use markdown to format the URLs to include the URL as part of the
            # hover-over text.
            #
            # Discord eats extra spaces, but doesn't recognize the "zero width" space character, so we
            # insert that on an extra line in order to provide more spacing between elements
            value = "[dps.report](${dps_report} `"${dps_report}`") @MIDDLEDOT@ [gw2raidar](${url} `"${url}`")`r`n@UNICODE-ZWS@"
            # Where possible, we want discord to keep these on the same lines
            inline = $true
        }
    }

    # Create a participants list separated by MIDDLE DOT unicode characters
    $participants = ($players | Select-Object -Unique) -join " @MIDDLEDOT@ "

    # Add a final field as the set of players.
    $fields += [PSCustomObject]@{
        name = "@EMDASH@ Raiders @EMDASH@"
        value = "${participants}"
    }

    # Determine which wings we did
    $wings = $($some_bosses | Sort-Object -Property {$_.time} | ForEach-Object {$_.wing} | Get-Unique) -join ", "

    $date = Get-Date -Format "MMM d, yyyy" -Date $date

    # Create the data object for this date, and add it to the list
    $data += [PSCustomObject]@{
        title = "${guild} Wings: ${wings} | ${date}"
        color = 0xf9a825
        thumbnail = $thumbnail
        fields = $fields
    }
}

# Create the payload object
$payload = [PSCustomObject]@{
    embeds = @($data)
}

# ConvertTo-JSON doesn't handle unicode characters very well, but we want to
# insert a zero-width space. To do so, we'll implement a variant that replaces
# a magic string with the expected value
#
# More strings can be added here if necessary. The initial string should be
# something innocuous which won't be generated as part of any URL or other
# generated text, and is unlikely to appear on accident
Function Convert-Payload($payload) {
    # Convert the object into a JSON string, using an increased
    # depth so that the ConvertTo-Json will completely convert
    # the layered object into JSON.
    $json = ($payload | ConvertTo-Json -Depth 10)

    $unicode_map = @{"@UNICODE-ZWS@"="\u200b";
                     "@BOXDASH@"="\u2500";
                     "@EMDASH@"="\u2014";
                     "@MIDDLEDOT@"="\u00B7"}

    # Because ConvertTo-Json doesn't really handle all of the
    # unicode characters, we need to insert these after the fact.
    $unicode_map.GetEnumerator() | ForEach-Object {
        $json = $json.replace($_.key, $_.value)
    }
    return $json
}

# Store the JSON if we've generated if we have a location
if (Test-Path $encounters_file) {
    (Convert-Payload $payload) | Out-File $encounters_file
}

# Send this request to the discord webhook
Invoke-RestMethod -Uri $discord_webhook -Method Post -Body (Convert-Payload $payload)

# Update the $last_format_file with the new format time, so that
# future runs won't repost old links
if (Test-Path $last_format_file) {
    $this_format_time | Select-Object -Property DateTime| ConvertTo-Json | Out-File -Force $last_format_file
}
